import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf
import plotly.graph_objects as go
from statsmodels.tsa.stattools import adfuller
from ts_model import *

def print_choose():
    st.info("У цьому розділі спробуємо узагальнити наші підходи до \
            вирішення поставленої задачі та обгрунтувати їх.")
    st.markdown("Для початку виберіть відповідну дію із пункту 'Оберіть розділ' на бічній панелі меню")

def print_intro():
    st.title("Вступ: коротко про головне")
    st.info("Всі права захищені бай Китобій ")
    #st.subheader("Підзаголовок Підзаголовок Підзаголовок Підзаголовок ")
    
def task_info():
    st.title("Про задачу")
	# Мета
    st.subheader("Мета:")
    st.markdown("Побудова моделі для прогнозування курсу гривні до USD за допомогою машинного навчання")
	# Вхідні дані
    st.subheader("Вхідні дані:")
    st.markdown("Для вирішення даної задачі були використані дані з відкритих джерел, серед яких \
                **макроекономічні показники Украни** та **щоденні зніми курсу гривні до USD**")
    features_info = pd.DataFrame(['індекс цін виробників', 'індекс інфляції', 'золотовалютні резерви', 'індекс цін сільськогосподарської продукції',
                                               'ВВП на душу населення грн', 'рівень безробіття', 'платіжний баланс (долл)', 'виконання державного бюджету(сальдо)',
                                               'сальдо експорт/імпорт', 'загальний держборг (грн)', 'індекс промислового виробництва', 'індекс заробітної плати', 'прямі іноземні інвестиції'],
                                 index = ['ppi', 'inflation', 'fx_reserves', 'agro_ppi',
                                               'gdp_pers_uah', 'unemployment', 'bop', 'gov_budg',
                                               'int_trade', 'state_debt_uah', 'ipi', 'rsi', 'fdi'],
                                 columns=['Показник'])
    st.table(features_info)
    st.subheader("Обрана метрика якості:")
    st.markdown("**Mean absolute error**. Це інтерпретаційний показник, оскільки він має ту саму одиницю вимірювання, що і початковий ряд. \
                Перевага в тому, що помилки з різними знаками, але рівні по модулю, не взаємознищуються")
    st.latex(r'''MAE = \frac{\displaystyle\sum_{i=1}^n|y_{pred} - y_{true}|}{n}''')
    
    
def print_command_review():
    st.title("Команда Китобій")
	# Команда
    #st.subheader(":")
    st.markdown(":heavy_check_mark: **Цепа Олексій** - КПІ ІПСА 2 курс; Капітан, Data Science, \
                Data Mining, Feature engineering, Пітч ([LinkedIn](https://www.linkedin.com/in/oleksii-tsepa-9435801a4/))")
    st.markdown(":heavy_check_mark: **Самошин Андрій** - КПІ ІПСА 2 курс; Data Science, ML, \
                Feature engineering, Презентація ([LinkedIn](https://www.linkedin.com/in/andriy-samoshyn-748b56163/))")
    st.markdown(":heavy_check_mark: **Мисак Юрій** - КПІ ФПМ 2 курс; Data Science, ML, Math, Пітч")

def print_litterature():
    st.title("Використана література")
	# Література
    st.markdown("Текст Текст Текст Текст")
    st.markdown("Текст Текст Текст Текст")
    st.markdown("Текст Текст Текст Текст")
    
def print_about_economic_features_model():
    st.subheader("Модель на економічних параметрах України")
    #st.title("На економічних параметрах України")

    st.markdown("Базуючись на макроекономічних показниках країни, необхідно передбачити курс валют на найближчий час. \
                В даному випадку використовувалась система градієнтного підсилення.")
    data = download_data_economic()
    st.dataframe(data.tail(5))
    st.markdown("Ці дані сповна характеризують економічну ситуацію в Україні, але мають **ряд суттєвих недоліків**, через \
                які нам довелося змінити підхід до задачі:\n - Більшість параметрів розраховуються щомісячно або щоквартально, а наша ціль, курс валют, щоденно. Будь-які \
                    види інтерполяції не зможуть повноцінно відобразити тренди параметрів на кожен день\n - На жаль, економічна ситуація у країні не є досить стабільною через що виникає багато аномальних значень, \
                    які будуть заважати роботі моделей. Ми не можемо їх уникнути, тому что це реальні показники\n")
    st.markdown("**Як результат**, маємо набір даних, який складно якісно математично інтерпретувати на кожен день та який містить \
                досить велику кількість пропущенної інформації через алгоритми підрахунку.")
    
def print_about_time_series_model():
    st.subheader("Модель із використанням часових рядів")
    st.info("Часовий ряд - це ряд точок даних, індексованих (або перерахованих) у часовому порядку.")
	# Література
    st.markdown("Тобто дані організовані за відносно детермінованими часовими позначками і можуть, порівняно із випадковими даними вибірки, містити додаткову інформацію, яку ми можемо проаналізувати. \
                **У нашому випадку таким рядом є курс гривні до USD.**")
    data = download_data_usd()
    st.line_chart(data)
    #fig = go.Figure(data=[
    #go.Bar(name='Cases', x=data.index, y=data)])
    # Change the bar mode
    #fig.update_layout(barmode='overlay', title='Worldwide daily Case and Death count')
    #st.plotly_chart(fig)
    
    st.markdown("Але, як ми переконались під час вирішення задачі, моделі для часових рядів (ARIMA/SARIMA) не є оптимальними в даному випадку через відсутність \
                певних закономірностей у часовому ряді курсу гривні. \
                До того ж, вони не є вигідними с точки зору запуску в продакшен: вимагають багато часу на підготовку даних, потребують частої перепідготовки та \
                    вони є важно налаштовуваними.")
    st.markdown("**Тому ми створили набір функцій із існуючого часового ряду та побудували модель регресії.**")
    st.markdown("**Які функції ми можемо витягти?**\n - Запізнення часового ряду\n - Статистики за певний період (мінімальне/максимальне, середне значення, \
                дисперсія)\n - Напрями трендів\n - Стрімкість зміни часового ряду\n - Перевірка гіпотези про стаціонарність окремих проміжків")
    
    st.subheader("Запізнення часового ряду")
    st.markdown("Для підтвердження гіпотези про можливість розробки такої моделі побудуємо графік **автокореляції ряду**, щоб побачити чи корелюють між собою запізнення часового ряду, адже вони будуть відігравати \
                провідну роль у майбутній моделі.")
    plot_acf(data, lags = range(0,30))
    st.pyplot()
    st.markdown("Довірчі інтервали зображені у вигляді конуса. 95% довірчий інтервал дозволяє припустити, що значення кореляції поза цим конусом є кореляцією, а не статистичною величиною.")
    data_shift = pd.DataFrame()
    for i in range(0, 12, 4):
        data_shift["lag_"+ str(i)] = data.shift(i)
        #print(data.head())
        plt.plot(data_shift.loc['2019-04-01':'2019-07-01','lag_'+ str(i)], label='lag_'+ str(i))
    #plt.plot(data_shift.loc['2019-04-01':'2019-07-01',:])
    plt.legend()
    plt.title('Приклад запізнення на 4 та 8 днів')
    st.pyplot()
    st.subheader("Статистики за певний період")
    st.markdown("Для того, щоб отримати більше інформації про наш часовий ряд, нам необхідно фіксувати певну статистичну інформацію на невеликих проміжках. \
                Ми зможемо вдосконалити модель, надавши додаткові дані про ряд. \
                _Проте не забуваємо, що необхідно підраховувати статистики саме на деякому запізненні ряду (а не на самому курсі) для того, щоб уникнути витіку даних._")
    period = data['2019-04-01':'2019-04-20']
    for i in range(1, len(period)):
        if period.iloc[i]>period.iloc[i-1]:
            plt.plot(period.iloc[i-1:i+1], color='limegreen', linewidth=3)
        elif period.iloc[i]<period.iloc[i-1]:
            plt.plot(period.iloc[i-1:i+1], color='tomato', linewidth=3)
        else:
            plt.plot(period.iloc[i-1:i+1], color='grey', linewidth=3)
            
    plt.axhline(y=period.min(), linestyle='--', linewidth=0.8, color='darkorange', label='min')
    plt.axhline(y=period.max(), linestyle='--', linewidth=0.8,color='darkorange', label='max')
    plt.axhline(y=period.mean(), linestyle='--', color='tan', label='mean')

    plt.legend()
    plt.title('Обрані статистики для аналізу')
    st.pyplot()
    st.subheader("Стаціонарність часового ряду")
    st.markdown("Якщо процес є стаціонарним, це означає, що він не змінює своїх статистичних властивостей у часі, а саме середнього значення та дисперсії. \
                Коваріаційна функція не залежить від часу; вона повинна залежати лише від відстані між спостереженнями.")
    st.markdown("**Чому стаціонарність так важлива?** Тому що робити прогнози на стаціонарних рядах легше, оскільки можна припустити, що майбутні статистичні властивості не будуть відрізнятися від тих, що спостерігаються в даний час. \
                Тому ми перевіряємо гіпотезу про стаціонарність **(тест Дікі-Фуллера)** окремих проміжків часу та додаємо цю інформацію в модель.")
    st.markdown("**Тест Дікі-Фуллера:**\n - **Нульова гіпотеза:** часовий ряд є не стаціонарним (має деяку залежну від часу \
                структуру)\n - **Альтернативна гіпотеза:** (відкидаючи нульову гіпотезу) часовий ряд є стаціонарним \
        \n - Ми інтерпретуємо цей результат, використовуючи **р-значення** з тесту. Значення р нижче порогового рівня 5% пропонує нам відкинути нульову гіпотезу, інакше дозволяє припустити нульову гіпотезу")
    stat_period = data['2015-05-20':'2015-06-05']
    plt.plot(stat_period[:'2015-05-30'], color='green', linewidth=3, label=f'Dickey-Fuller p-value: {round(adfuller(stat_period[:"2015-05-30"])[1], 3)}')
    plt.plot(stat_period['2015-05-30':], color='royalblue', linewidth=3, label=f'Dickey-Fuller p-value: {round(adfuller(stat_period["2015-05-30":])[1], 3)}')    
    plt.axvline(pd.to_datetime('2015-05-30'), color='k', linestyle='--')
    plt.title('Порівняння стаціонарного і нестаціонарного періодів')
    plt.legend()
    st.pyplot()
    st.subheader("Вдосконалення даного методу")
    st.markdown("Для більш точного прогнозування на великі терміни (більше 14 днів), ми розробили модель із донавчанням на певних етапах. \
                **Ідея наступна:**\n - Розбити термін на декілька коротких, на яких модель добре передбачає курс\n - Спрогнозувати на перший такий проміжок, представити ці дані як істинні та додати \
                    їх до навчальної вибірки\n - Вже на наново навченій моделі спрогнозувати наступний міні-проміжок\n - Повторити для всіх проміжків\n - З'єднати прогнози на кождій ітерації")
    st.markdown("**Як результат, зменшили похибку на великих термінах в середьному на 15 копійок.**")
    
def intro_model():
    st.info("Цей розділ допоможе вам зробити та візуалізувати прогнози, представлені нашою моделлю. А також допоможемо інтерпретувати модель для кращого розуміння сутності всіх процесів.")
    st.markdown("Для того, аби отримати результати роботи, вам необхідно обрати декілька налаштувань.")
    
def select_predict_size():
    st.subheader("Довжина передбачення")
    st.markdown("За допомогою слайдеру нижче оберіть бажаную кількість днів, на яку необхідно передбачити курс.")
    predict_size = st.slider('Кількість днів', min_value=2, max_value=30)
    st.write("Ви обрали ", predict_size, " днів для прогнозу")
    return predict_size

def select_type_learning(predict_size):
    if predict_size>7:
        st.subheader("Тип навчання")
        st.markdown("Оберіть як прогнозувати курс: звичайне навчання чи навчання з підкріпленням.")
        select = st.radio("Оберіть бажане", ["Звичайне навчання", "Навчання з підкріпленням"])
    else:
        select = "Звичайне навчання"
    if select=="Навчання з підкріпленням":
        st.markdown("Оберіть довжину періоду, який викорисовувати для підкріплення _(коротше період - менше похибка, але неодхідно більше часу для підрахунків)_")
        sеlect_step = st.radio("Оберіть період", [2, 3, 4, 5])
    else:
        sеlect_step = 0
    return select, sеlect_step
 
def print_res(y_true, y_pred, mae, X_test, pred_size):
    st.subheader("**Прогноз сформовано!** Отримані результати наступні:")
    st.write("Середня похибка прогнозу на ", pred_size, " днів склала ", round(mae*100,2)," (у копійках).")
    st.markdown("Переглянути **фактичні та отримані значення** можна у таблиці нижче.")
    conf = pd.DataFrame(data={'Реальні значення': y_true, 'Прогноз': y_pred, }, index=X_test.index)
    st.dataframe(conf)
    
def intro_shap():
    st.subheader("Пояснення моделі простою мовою")
    st.markdown("За допомогою **SHAP-значень** можна зрозуміти, наскільки наші дані дають той чи інший вклад у фінальний прогноз курсу. Проілюструємо це на роботі нашої моделі. **Оберіть на скільки днів зробити прогноз:**")