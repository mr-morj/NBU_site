import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf
from statsmodels.tsa.stattools import adfuller
from PIL import Image
from ts_model import *

def print_choose():
    st.info("У цьому розділі спробуємо узагальнити наші підходи до \
            вирішення поставленої задачі та обгрунтувати їх.")
    st.markdown("Для початку виберіть відповідну дію із пункту 'Оберіть розділ' на бічній панелі меню")

def print_intro():
    st.title("Вступ: коротко про головне")
    st.info("Всі права захищені командою Китобій ")
    
def task_info():
    st.title("Про задачу")
    st.subheader("Мета:")
    st.markdown("Побудова моделі для прогнозування курсу гривні до USD за допомогою машинного навчання")
    st.subheader("Вхідні дані:")
    st.markdown("Для вирішення даної задачі були використані дані з відкритих джерел, серед яких \
                **макроекономічні показники Украни** та **щоденні зніми курсу гривні до USD**")
    features_info = pd.DataFrame(['індекс цін виробників', 'індекс інфляції', 'золотовалютні резерви', 'індекс цін сільськогосподарської продукції',
                                               'ВВП на душу населення грн', 'рівень безробіття', 'платіжний баланс (долл)', 'виконання державного бюджету(сальдо)',
                                               'сальдо експорт/імпорт', 'загальний держборг (грн)', 'індекс промислового виробництва', 'індекс заробітної плати', 'прямі іноземні інвестиції'],
                                 index = ['ppi', 'inflation', 'fx_reserves', 'agro_ppi',
                                               'gdp_pers_uah', 'unemployment', 'bop', 'gov_budg',
                                               'int_trade', 'state_debt_uah', 'ipi', 'rsi', 'fdi'],
                                 columns=['Показник'])
    st.table(features_info)
    st.subheader("Обрана метрика якості:")
    st.markdown("**Mean absolute error**. Це інтерпретаційний показник, оскільки він має ту саму одиницю вимірювання, що і початковий ряд. \
                Перевага в тому, що помилки з різними знаками, але рівні по модулю, не взаємознищуються")
    st.latex(r'''MAE = \frac{\displaystyle\sum_{i=1}^n|y_{pred} - y_{true}|}{n}''')
    
    
def print_command_review():
    st.title("Команда Китобій")
    st.subheader("Склад команди")
    st.markdown(":heavy_check_mark: **Цепа Олексій** – КПІ ІПСА 2 курс; Капітан, Data Science, \
                Data Mining, Feature engineering, Пітч ([LinkedIn](https://www.linkedin.com/in/oleksii-tsepa-9435801a4/))")
    st.markdown(":heavy_check_mark: **Самошин Андрій** – КПІ ІПСА 2 курс; Data Science, ML, \
                Feature engineering, Презентація ([LinkedIn](https://www.linkedin.com/in/andriy-samoshyn-748b56163/))")
    st.markdown(":heavy_check_mark: **Мисак Юрій** – КПІ ФПМ 2 курс; Data Science, ML, Math, Пітч")
    st.subheader("Ментори")
    st.markdown(":heavy_check_mark: **Калиновська Людмила Григорівна** – лідер напряму автоматизації банківських операцій")
    st.markdown(":heavy_check_mark: **Кущ Максим Сергійович** – заступник начальника управління з розробки банківських інформаційних систем НБУ")
def raw_plot(data, column_name, title):

    plt.plot(data.index, data[column_name], label=column_name)
    plt.legend()
    plt.title(title)

def fix_outliers(X, column):
    
    learning_rate = 0.35
    
    q1 = X[column].quantile(0.25)
    q3 = X[column].quantile(0.75)
    iqr = q3-q1
    fence_low  = q1-1.5*iqr
    fence_high = q3+1.5*iqr
    
    X[column].loc[(X[column] >= fence_high)] = X[column].quantile(1-learning_rate)
    X[column].loc[(X[column] <= fence_low)] = X[column].quantile(learning_rate)
    
    return X
        
def print_about_economic_features_model():
    st.subheader("Модель на економічних параметрах України")
    st.markdown("Базуючись на макроекономічних показниках країни, необхідно передбачити курс валют на найближчий час. \
                В даному випадку використовувалась система градієнтного підсилення.")
    data = download_data_economic()
    st.dataframe(data.tail(10))
    st.markdown("Ці дані сповна характеризують економічну ситуацію в Україні, але мають **ряд суттєвих недоліків для навчання (про це пізніше).**")
    st.markdown("**Побудова моделі складається з наступних етапів**:\n - Підготовка даних (preprocessing)\n - Робота з колонками (feature engineering)\n - Налаштування моделі (modelling)")
    
    st.subheader("Підготовка даних")
    st.markdown("Вся робота проходила із середнім місячним курсом, адже усі залежні показники вимірюються кожного місяця/квартала/року.")
    st.markdown("Використовували **лінійну інтерполяцію** для заповнення пропущених даних, що вимірюються не щомісячно.")
    st.markdown("Часовий проміжок для роботи з моделлю: **з 2015 по 2020 рік**, на якому і застосовувались методи оцінок для розуміння точності кожної моделі.")
    
    st.subheader("Робота з колонками")
    st.markdown("У вибірках деяких параметрів були наявні **викиди** (значення, які виділяються із загальної вибірки), що негативно впливають на роботу моделі. Вони виявлені та ліквідовані за допомогою **методу міжквартильного розмаху**.")
    raw_plot(data, 'ppi', 'До опрацювання даних')
    st.pyplot()
    data = fix_outliers(data, 'ppi')
    raw_plot(data, 'ppi', 'Після опрацювання даних')
    st.pyplot()
    st.markdown("Були додані “запізнення” для усіх колонок на 1,2,3,6 та 12 місяців. Детальніше щодо “запізнення” розкажемо в розділі про часові ряди.")
    st.markdown("**Вибір колонок, що дають найкращий результат.** Використали власноруч створену функцію по відбору найкорисніших колонок для моделювання, адже бустингова модель чутлива до колонок, що знаходяться в датасеті.")
    image1 = Image.open('diagram.png')
    st.image(image1,use_column_width=True)
    st.markdown("Валідація проводилась на основі **TimeSeriesSplit** із бібліотеки sklearn, щоб перевірити як модель себе показує на всьому датасеті. На діаграмі проілюстрований принцип розбиття на тренуальну та тестову частини.")
    image2 = Image.open('ts_split.png')
    st.image(image2,use_column_width=True)
    st.subheader("Налаштування моделі")
    st.markdown("Обрана **модель на основі бустингу XGBoost**. Також перевірялися наступні моделі: LightGBM, CatBoost, RandomForests, KNN та інші. Після вибору моделі, підбирали найкращі параметри моделі на основі кросс-валідації.")
    st.markdown("**Остаточний вигляд моделі наступний:**")
    st.info("XGBRegressor(objective ='reg:squarederror', learning_rate=0.3, n_estimators=100, max_depth=9, subsample=0.9, colsample_bytree=0.7)")
    st.markdown("де:\n - **learning_rate** - розмір кроку при корекції моделі, використовується для запобігання \
                перенавчання\n - **n_estimators** - кількість дерев у моделі\n - **max_depth** - максимальна глибина дерева\n - **subsample** - характеризує, яку частину строк буде \
                    використовувати модель на кожному кроці оновлення\n - **colsample_bytree** - відношення підвибірки колонок при побудові кожного дерева")
    
    st.subheader("Результати")
    st.markdown("**То чому ж ми відкинули цей підхід?** Таке рішення довелося прийняти через низку проблем:\n - Більшість параметрів розраховуються щомісячно або щоквартально, а наша ціль, курс валют, щоденно. Будь-які \
                    види інтерполяції не змогли повноцінно відобразити тренди параметрів на кожен день\n - На жаль, економічна ситуація у країні не є досить стабільною через що виникає багато аномальних значень, \
                    які заважають роботі моделі. Ми могли б їх ліквідувати, однак це реальні показники країни. Якщо всі ці значення прибрати, виникне зовсім інша економічна картина.")
    st.markdown("**Як підсумок**, маємо набір даних, який складно якісно математично інтерпретувати на кожен день та який містить \
                досить велику кількість пропущенної інформації через алгоритми підрахунку.")
    
def print_about_time_series_model():
    st.subheader("Модель із використанням часових рядів")
    st.info("Часовий ряд - це ряд точок даних, індексованих (або перерахованих) у часовому порядку.")
    st.markdown("Тобто дані організовані за відносно детермінованими часовими позначками і можуть, порівняно із випадковими даними вибірки, містити додаткову інформацію, яку ми можемо проаналізувати. \
                **У нашому випадку таким рядом є курс гривні до USD.**")
    data = download_data_usd()
    st.line_chart(data)
    st.markdown("Але, як ми переконались під час вирішення задачі, моделі для часових рядів (ARIMA/SARIMA) не є оптимальними в даному випадку через відсутність \
                певних закономірностей у часовому ряді курсу гривні. \
                До того ж, вони не є вигідними с точки зору запуску в продакшен: вимагають багато часу на підготовку даних, потребують частої перепідготовки та \
                    вони є важно налаштовуваними.")
    st.markdown("**Тому ми створили набір функцій із існуючого часового ряду та побудували модель регресії.**")
    st.markdown("**Які функції ми можемо витягти?**\n - Запізнення часового ряду\n - Статистики за певний період (мінімальне/максимальне, середне значення, \
                дисперсія)\n - Напрями трендів\n - Стрімкість зміни часового ряду\n - Перевірка гіпотези про стаціонарність окремих проміжків")
    
    st.subheader("Запізнення часового ряду")
    st.markdown("Для підтвердження гіпотези про можливість розробки такої моделі побудуємо графік **автокореляції ряду**, щоб побачити чи корелюють між собою запізнення часового ряду, адже вони будуть відігравати \
                провідну роль у майбутній моделі.")
    plot_acf(data, lags = range(0,30))
    st.pyplot()
    st.markdown("Довірчі інтервали зображені у вигляді конуса. 95% довірчий інтервал дозволяє припустити, що значення кореляції поза цим конусом є кореляцією, а не статистичною величиною.")
    data_shift = pd.DataFrame()
    fig, axs = plt.subplots(1, figsize=(6,4))
    for i in range(0, 12, 4):
        data_shift["lag_"+ str(i)] = data.shift(i)
        axs.plot(data_shift.loc['2019-04-01':'2019-07-01','lag_'+ str(i)], label='lag_'+ str(i))
    fig.autofmt_xdate()
    axs.legend()
    fig.suptitle('Приклад запізнення на 4 та 8 днів')
    st.pyplot()
    st.subheader("Статистики за певний період")
    st.markdown("Для того, щоб отримати більше інформації про наш часовий ряд, нам необхідно фіксувати певну статистичну інформацію на невеликих проміжках. \
                Ми зможемо вдосконалити модель, надавши додаткові дані про ряд. \
                _Проте не забуваємо, що необхідно підраховувати статистики саме на деякому запізненні ряду (а не на самому курсі) для того, щоб уникнути витіку даних._")
    period = data['2019-04-01':'2019-04-20']
    fig, axs = plt.subplots(1, figsize=(6,4))
    for i in range(1, len(period)):
        if period.iloc[i]>period.iloc[i-1]:
            axs.plot(period.iloc[i-1:i+1], color='limegreen', linewidth=3)
        elif period.iloc[i]<period.iloc[i-1]:
            axs.plot(period.iloc[i-1:i+1], color='tomato', linewidth=3)
        else:
            axs.plot(period.iloc[i-1:i+1], color='grey', linewidth=3)
            
    axs.axhline(y=period.min(), linestyle='--', linewidth=0.8, color='darkorange', label='min')
    axs.axhline(y=period.max(), linestyle='--', linewidth=0.8,color='darkorange', label='max')
    axs.axhline(y=period.mean(), linestyle='--', color='tan', label='mean')
    fig.autofmt_xdate()
    axs.legend()
    fig.suptitle('Обрані статистики для аналізу')
    st.pyplot()
    st.subheader("Стаціонарність часового ряду")
    st.markdown("Якщо процес є стаціонарним, це означає, що він не змінює своїх статистичних властивостей у часі, а саме середнього значення та дисперсії. \
                Коваріаційна функція не залежить від часу; вона повинна залежати лише від відстані між спостереженнями.")
    st.markdown("**Чому стаціонарність так важлива?** Тому що робити прогнози на стаціонарних рядах легше, оскільки можна припустити, що майбутні статистичні властивості не будуть відрізнятися від тих, що спостерігаються в даний час. \
                Тому ми перевіряємо гіпотезу про стаціонарність **(тест Дікі-Фуллера)** окремих проміжків часу та додаємо цю інформацію в модель.")
    st.markdown("**Тест Дікі-Фуллера:**\n - **Нульова гіпотеза:** часовий ряд є не стаціонарним (має деяку залежну від часу \
                структуру)\n - **Альтернативна гіпотеза:** (відкидаючи нульову гіпотезу) часовий ряд є стаціонарним \
        \n - Ми інтерпретуємо цей результат, використовуючи **р-значення** з тесту. Значення р нижче порогового рівня 5% пропонує нам відкинути нульову гіпотезу, інакше дозволяє припустити нульову гіпотезу")
    stat_period = data['2015-05-20':'2015-06-05']
    fig, axs = plt.subplots(1, figsize=(6,4))
    axs.plot(stat_period[:'2015-05-30'], color='green', linewidth=3, label=f'Dickey-Fuller p-value: {round(adfuller(stat_period[:"2015-05-30"])[1], 3)}')
    axs.plot(stat_period['2015-05-30':], color='royalblue', linewidth=3, label=f'Dickey-Fuller p-value: {round(adfuller(stat_period["2015-05-30":])[1], 3)}')    
    axs.axvline(pd.to_datetime('2015-05-30'), color='k', linestyle='--')
    fig.suptitle('Порівняння стаціонарного і нестаціонарного періодів')
    fig.autofmt_xdate()
    axs.legend(loc=1)
    st.pyplot()
    st.subheader("Вдосконалення даного методу")
    st.markdown("Для більш точного прогнозування на великі терміни (більше 14 днів), ми розробили модель із донавчанням на певних етапах. \
                **Ідея наступна:**\n - Розбити термін на декілька коротких, на яких модель добре передбачає курс\n - Спрогнозувати на перший такий проміжок, представити ці дані як істинні та додати \
                    їх до навчальної вибірки\n - Вже на наново навченій моделі спрогнозувати наступний міні-проміжок\n - Повторити для всіх проміжків\n - З'єднати прогнози на кождій ітерації")

def about_col():
    st.markdown("Для початку додамо деякі пояснення щодо назв змінних, що використовувалися при моделюванні:")
    columns_info = pd.DataFrame(['запізнення часового ряду на n днів', 'мінімальне значення у вікні розміром n', 'максимальне значення у вікні розміром n', 'середнє значення у вікні розміром n',
                                               'дисперсія у вікні розміром n', '25% квартиль у вікні розміром n', '75% квартиль у вікні розміром n', 'зміна величини часового ряду у вікні розміром n відповідно до найменшого доступного вікна',
                                               'бінарний показник росту чи спаду найменшого відставання часового ряду', 'щоденна різниця величини мінімального запізнення часового ряду', 'p-значення перевірки гіпотези про стаціонарність часового ряду у вікні розміром n'],
                                 index = ['shift_n', 'roll_min_n', 'roll_max_n', 'roll_mean_n',
                                               'roll_std_n', 'roll_q25_n', 'roll_q75_n', 'diff_shift_n',
                                               'period_trend', 'day_increase', 'window_stationarity_n'],
                                 columns=['Опис колонки'])
    st.table(columns_info)
    
def intro_model():
    st.info("Цей розділ допоможе вам зробити та візуалізувати прогнози, представлені нашою моделлю. А також допоможемо інтерпретувати модель для кращого розуміння сутності всіх процесів.")
    st.markdown("Для того, аби отримати результати роботи, вам необхідно обрати декілька налаштувань.")
    
def select_predict_size():
    st.subheader("Довжина передбачення")
    st.markdown("За допомогою слайдеру нижче оберіть бажаную кількість днів, на яку необхідно передбачити курс.")
    predict_size = st.slider('Кількість днів', min_value=2, max_value=30)
    st.write("Ви обрали ", predict_size, " днів для прогнозу")
    return predict_size

def select_fs():
    st.subheader("Відбір функцій")
    st.markdown("**Які його переваги?**\n- спрощення моделі\n- скорочення \
                тривалості фінального навчання\n- зменшення розмірості даних\n- покращення узагальнення шляхом зниження перенавчання")
    sеlect_selection = st.radio("Оберіть необіхне", ["З відбором", "Без відбору"])
    return sеlect_selection

def select_type_learning(predict_size):
    if predict_size>7:
        st.subheader("Тип навчання")
        st.markdown("Оберіть як прогнозувати курс: звичайне навчання чи навчання з підкріпленням.")
        select = st.radio("Оберіть бажане", ["Звичайне навчання", "Навчання з підкріпленням"])
    else:
        select = "Звичайне навчання"
    if select=="Навчання з підкріпленням":
        st.markdown("Оберіть довжину періоду, який викорисовувати для підкріплення _(коротше період - менше похибка, але неодхідно більше часу для підрахунків)_")
        sеlect_step = st.radio("Оберіть період", [2, 3, 4, 5])
    else:
        sеlect_step = 0
    return select, sеlect_step
 
def print_res(y_true, y_pred, mae, X_test, pred_size, tm):
    st.subheader("**Прогноз сформовано!** Отримані результати наступні:")
    st.write("Середня похибка прогнозу на ", pred_size, " днів склала ", round(mae*100,2)," (у копійках).")
    st.write("Час роботи моделі: ", round(tm, 3), " секунд")
    st.markdown("Переглянути **фактичні та отримані значення** можна у таблиці нижче.")
    conf = pd.DataFrame(data={'Реальні значення': y_true, 'Прогноз': y_pred, }, index=X_test.index)
    st.dataframe(conf)
    
def intro_shap():
    st.subheader("Пояснення моделі простою мовою")
    about_col()
    st.markdown("За допомогою **SHAP-значень** можна зрозуміти, наскільки наші дані дають той чи інший вклад у фінальний прогноз курсу. Проілюструємо це на роботі нашої моделі. **Оберіть на скільки днів зробити прогноз:**")